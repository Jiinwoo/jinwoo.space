{"componentChunkName":"component---src-templates-post-template-tsx","path":"/lecture/Real-Mysql/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<blockquote>\n<p>강의 내용 중 필요하다고 생각되는 부분과 개인적인 생각을 포함했습니다.</p>\n</blockquote>\n<h1>MySQL 성능 최적화 가이드</h1>\n<h2>TEXT VS VARCHAR</h2>\n<p>데이터 조회 시 주의사항:</p>\n<ul>\n<li>대용량 컬럼이 불필요한 경우 SELECT 시 제외하고 쿼리하기</li>\n<li>큰 데이터가 있는 경우 Off-Page 저장으로 인해 성능 저하 가능</li>\n<li>대용량 컬럼을 자주 조회해야 하는 경우 Redis 같은 캐시 솔루션 고려</li>\n</ul>\n<h2>Count(*) &#x26; Select * 비교</h2>\n<h3>쿼리 예시</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">/* Count 쿼리 */</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">WHERE</span> ix_fd <span class=\"token operator\">=</span> <span class=\"token string\">'A'</span> <span class=\"token operator\">AND</span> non_ix_fd <span class=\"token operator\">=</span> <span class=\"token string\">'B'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/* All 쿼리 */</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">WHERE</span> ix_fd <span class=\"token operator\">=</span> <span class=\"token string\">'A'</span> <span class=\"token operator\">AND</span> non_ix_fd <span class=\"token operator\">=</span> <span class=\"token string\">'B'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>두 쿼리의 특징:</p>\n<ul>\n<li>네트워크 트래픽을 제외하면 거의 동일한 성능</li>\n<li>처리 과정:\n<ol>\n<li>인덱스된 ix_fd로부터 레코드 조회</li>\n<li>non_ix_fd 비교를 위한 테이블 액세스 수행</li>\n</ol>\n</li>\n</ul>\n<h3>Covering Index 활용</h3>\n<blockquote>\n<p><strong>Covering Index</strong>: 쿼리 실행에 필요한 모든 데이터를 인덱스에서 가져오는 방식</p>\n</blockquote>\n<p>최적화된 쿼리 예시:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">WHERE</span> ix_fd <span class=\"token operator\">=</span> <span class=\"token string\">'A'</span> <span class=\"token operator\">AND</span> ix_fd <span class=\"token operator\">=</span> <span class=\"token string\">'B'</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">-- 또는</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span>ix_fd<span class=\"token punctuation\">)</span> <span class=\"token keyword\">WHERE</span> ix_fd <span class=\"token operator\">=</span> <span class=\"token string\">'A'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>주의사항:</p>\n<ul>\n<li>실제 환경에서는 인덱스 컬럼만으로 Count 쿼리를 구성하기 어려움</li>\n<li>모든 컬럼을 인덱스로 만드는 것은 권장되지 않음</li>\n</ul>\n<h2>Count(*) &#x26; Count(DISTINCT)</h2>\n<p>특징 비교:</p>\n<ul>\n<li><strong>Count(*)</strong>: 단순 레코드 수 확인</li>\n<li><strong>Count(DISTINCT)</strong>: 임시 테이블 생성 후 중복 제거된 레코드 수 확인</li>\n</ul>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 727px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/4854026484caab2806c79a7f0ab04067/96343/count_distinct.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 33.33333333333333%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABbklEQVR42m2RDWsTQRCG8/9/h0WCtGiFBNtirCltkr2vNKFajYELIULS5uN6H3u7e/e4e1Ks6MDDDDPDO7OzLW00iTqQlim5ysisd7HUklrVqFxhZIUpDXmeUeQ58ikj3e8pihylS4tCa93QKqVkOh4ziSJCz2cchkyCkNnyG2ERIhJBkAZMd7dMJhF+r0/vtMNl94zgY5/Z/Veqyg40pqEliwIxHCJGgvfvTjn/cEY4DPBmI453JxyvT2hv3tD92cXv3/Cpc87rdptXR0dcvO1wN76lqq2gfiEYCIEvPDwr6tlYDEbM4++s9ZpltmRVrlglK6bCJ/p8TTAcEV3eEPSuuP9y9++Gnttw8BvPNg+urlnGC5zVpobK+qrG3dvIkuqpQO9SW6uauyml/gi6xPbh4S8eNxuyNMVUphFpsH1O9HG75cd8ThzHLBaLhmdBt2nLBf+zl894xuWk/cS9/eHD4UCSJKRusKtZDrnkF0S2BtNs2Qn8AAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/4854026484caab2806c79a7f0ab04067/a59e9/count_distinct.webp 192w,\n/static/4854026484caab2806c79a7f0ab04067/0ca9f/count_distinct.webp 384w,\n/static/4854026484caab2806c79a7f0ab04067/c55bc/count_distinct.webp 727w\"\n              sizes=\"(max-width: 727px) 100vw, 727px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/4854026484caab2806c79a7f0ab04067/3b721/count_distinct.png 192w,\n/static/4854026484caab2806c79a7f0ab04067/66595/count_distinct.png 384w,\n/static/4854026484caab2806c79a7f0ab04067/96343/count_distinct.png 727w\"\n            sizes=\"(max-width: 727px) 100vw, 727px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/4854026484caab2806c79a7f0ab04067/96343/count_distinct.png\"\n            alt=\"중복 데이터 확인 프로세스\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<h3>Count(*) 최적화 방법</h3>\n<ol>\n<li>불필요한 쿼리 제거</li>\n<li>대략적인 건수 활용</li>\n<li>WHERE 조건이 없는 경우 INFORMATION_SCHEMA.TABLES 활용</li>\n</ol>\n<h2>페이징 쿼리 최적화</h2>\n<blockquote>\n<p><a href=\"https://cheese10yun.github.io/page-performance/\" target=\"_blank\" rel=\"nofollow\">JPA에서 Page 쿼리 성능 최적화</a></p>\n</blockquote>\n<h3>LIMIT &#x26; OFFSET 문제점</h3>\n<ul>\n<li>DBMS가 순차적으로 레코드를 읽어야 함</li>\n<li>OFFSET이 커질수록 성능 저하</li>\n<li>전체 레코드를 읽는 것보다 비효율적</li>\n</ul>\n<h3>최적화 방법</h3>\n<h4>1. 범위 기반 방식</h4>\n<ul>\n<li>배치, 데이터 마이그레이션 등에 적합</li>\n<li>1회차와 N회차 쿼리 형태가 동일</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span>\n<span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">BETWEEN</span> <span class=\"token number\">100</span> <span class=\"token operator\">AND</span> <span class=\"token number\">200</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span>\n<span class=\"token keyword\">WHERE</span> <span class=\"token keyword\">data</span> <span class=\"token operator\">BETWEEN</span> <span class=\"token string\">'2020-01-01'</span> <span class=\"token operator\">AND</span> <span class=\"token string\">'2020-01-31'</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h4>2. 데이터 개수 기반 방식</h4>\n<p>첫 조회와 이후 쿼리를 분리하여 처리</p>\n<p>예시 데이터:</p>\n<table>\n<thead>\n<tr>\n<th>finished_at</th>\n<th>id</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>2020-01-01</td>\n<td>5</td>\n</tr>\n<tr>\n<td>2020-01-01</td>\n<td>1</td>\n</tr>\n<tr>\n<td>2020-01-01</td>\n<td>2</td>\n</tr>\n<tr>\n<td>2020-01-01</td>\n<td>3</td>\n</tr>\n<tr>\n<td>2020-01-02</td>\n<td>8</td>\n</tr>\n</tbody>\n</table>\n<p>쿼리 구현:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">/* 첫 조회 쿼리 */</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span>\n<span class=\"token keyword\">WHERE</span> finished_at <span class=\"token operator\">>=</span> <span class=\"token string\">\"시작날짜\"</span>\n  <span class=\"token operator\">AND</span> finished_at <span class=\"token operator\">&lt;</span> <span class=\"token string\">\"종료날짜\"</span>\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> finished_at<span class=\"token punctuation\">,</span> id\n<span class=\"token keyword\">LIMIT</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/* 이후 쿼리 */</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span>\n<span class=\"token keyword\">WHERE</span> <span class=\"token punctuation\">(</span>finished_at <span class=\"token operator\">=</span> <span class=\"token string\">\"이전 마지막 데이터의 날짜 값\"</span> <span class=\"token operator\">AND</span> id <span class=\"token operator\">></span> <span class=\"token string\">\"이전 데이터의 ID\"</span><span class=\"token punctuation\">)</span>\n   <span class=\"token operator\">OR</span> <span class=\"token punctuation\">(</span>finished_at <span class=\"token operator\">></span> <span class=\"token string\">\"이전 마지막 데이터의 날짜 값\"</span> <span class=\"token operator\">AND</span> finished_at <span class=\"token operator\">&lt;</span> <span class=\"token string\">\"종료날짜\"</span><span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">ORDER</span> <span class=\"token keyword\">BY</span> finished_at<span class=\"token punctuation\">,</span> id\n<span class=\"token keyword\">LIMIT</span> <span class=\"token number\">30</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><strong>주의</strong>: 이전 데이터의 ID만 WHERE 조건으로 사용하면 데이터 누락 가능성 있음</p>\n<h2>Stored Function</h2>\n<h3>MySQL Function 종류</h3>\n<ol>\n<li>Built-in Function</li>\n<li>User Defined Function</li>\n<li>Stored Function</li>\n</ol>\n<h3>Stored Function 특징</h3>\n<h4>Deterministic Function</h4>\n<ul>\n<li>동일한 인자에 대해 항상 동일한 결과 반환</li>\n<li>Primary key 읽을 때 const 타입으로 처리</li>\n<li>실행계획에서 재수행되지 않아 성능이 좋음</li>\n</ul>\n<h4>Not Deterministic Function</h4>\n<ul>\n<li>동일한 인자에 대해 결과가 다를 수 있음</li>\n<li>Primary key 읽을 때 All 타입으로 처리</li>\n<li>Index를 사용하지 못하고 Full Scan 발생</li>\n<li>대표적인 예: RAND(), NOW(), UUID(), SYSDATE()\n<ul>\n<li>NOW()는 하나의 Statement 내에서는 Deterministic처럼 동작</li>\n</ul>\n</li>\n</ul>\n<h3>주의사항</h3>\n<ul>\n<li>기본값은 NOT DETERMINISTIC</li>\n<li>DEFINER: Stored Function 소유자 지정 옵션</li>\n<li>SQL Security: 실행 권한 지정 (INVOKER 권장)</li>\n</ul>\n<h2>Lateral Derived Table</h2>\n<p>LATERAL은 FROM 절에서 파생 테이블이나 테이블 함수가 이전 항목을 참조할 수 있게 하는 기능입니다.</p>\n<h2>SELECT .. FOR UPDATE</h2>\n<p><a href=\"https://hudi.blog/mysql-8.0-shared-lock-and-exclusive-lock/\" target=\"_blank\" rel=\"nofollow\">공유 락(Shared Lock)과 배타 락(Exclusive Lock)</a></p>\n<h3>특징</h3>\n<ul>\n<li>격리 수준과 무관하게 최신 커밋 데이터 조회</li>\n<li>Exclusive Lock 사용</li>\n<li>원격 시스템 처리 시 트랜잭션이 길어질 수 있음</li>\n</ul>\n<h3>권장사항</h3>\n<ul>\n<li>WHERE 조건을 최대한 구체적으로 사용</li>\n<li>트랜잭션 시간 최소화</li>\n</ul>\n<h2>SELECT .. FOR SHARE</h2>\n<h3>사용 예시</h3>\n<p>부모-자식 테이블 관계에서 데이터 정합성 유지:</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">BEGIN</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> article <span class=\"token keyword\">WHERE</span> id <span class=\"token operator\">=</span> <span class=\"token number\">1</span> <span class=\"token keyword\">FOR</span> <span class=\"token keyword\">SHARE</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">IF</span> <span class=\"token punctuation\">(</span>article<span class=\"token punctuation\">.</span>canAddComment<span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span> {\n   <span class=\"token keyword\">INSERT</span> <span class=\"token keyword\">INTO</span> <span class=\"token keyword\">comment</span> <span class=\"token punctuation\">(</span>article_id<span class=\"token punctuation\">,</span> content<span class=\"token punctuation\">)</span> <span class=\"token keyword\">VALUES</span> <span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token string\">'comment'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n   <span class=\"token keyword\">COMMIT</span><span class=\"token punctuation\">;</span>\n} <span class=\"token keyword\">ELSE</span> {\n    <span class=\"token keyword\">ROLLBACK</span><span class=\"token punctuation\">;</span>\n}</code></pre></div>\n<h3>주의사항</h3>\n<ul>\n<li>Article 수정이 필요한 경우 처음부터 FOR UPDATE 사용 권장</li>\n<li>FOR SHARE에서 FOR UPDATE로의 잠금 업그레이드는 데드락 위험</li>\n</ul>\n<h2>JPA Optimistic Lock VS Pessimistic Lock</h2>\n<h3>락 유형 비교</h3>\n<p><strong>Optimistic Locking</strong>:</p>\n<ul>\n<li>데이터 변경 시점에 잠금</li>\n<li>Application Level에서 구현 필요</li>\n<li>충돌이 적은 경우에 적합</li>\n</ul>\n<p><strong>Pessimistic Locking</strong>:</p>\n<ul>\n<li>데이터 조회 시점에 잠금</li>\n<li>MySQL 서버에서 직접 지원</li>\n<li>충돌이 많은 경우에 적합</li>\n</ul>\n<blockquote>\n<p><a href=\"https://seongwon.dev/Spring-MVC/20230430-%EB%B9%84%EA%B4%80%EC%A0%81%EB%9D%BD%EA%B3%BC_%EB%82%99%EA%B4%80%EC%A0%81%EB%9D%BD/\" target=\"_blank\" rel=\"nofollow\">자세한 내용 참고</a></p>\n</blockquote>\n<h2>Generated Column</h2>\n<h3>유형과 특징</h3>\n<h4>1. Virtual Column</h4>\n<ul>\n<li>실시간 계산된 값 반환</li>\n<li>디스크에 저장하지 않음</li>\n<li>레코드 읽기 전 또는 BEFORE 트리거 실행 직후 계산</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> t1 <span class=\"token punctuation\">(</span>\n    a <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span>\n    b <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span>\n    c <span class=\"token keyword\">INT</span> <span class=\"token keyword\">AS</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span> VIRTUAL\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>특징:</p>\n<ul>\n<li>인덱스 생성 가능 (인덱스는 디스크에 저장)</li>\n<li>일반 칼럼과의 상호 변환 불가</li>\n</ul>\n<h4>2. Stored Column</h4>\n<ul>\n<li>계산된 값을 실제로 저장</li>\n<li>삽입/갱신 시 계산하여 저장</li>\n<li>인덱스 생성 가능</li>\n</ul>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">TABLE</span> t1 <span class=\"token punctuation\">(</span>\n    a <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span>\n    b <span class=\"token keyword\">INT</span><span class=\"token punctuation\">,</span>\n    c <span class=\"token keyword\">INT</span> <span class=\"token keyword\">AS</span> <span class=\"token punctuation\">(</span>a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">)</span> STORED\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>특징:</p>\n<ul>\n<li>일반 칼럼과 상호 변환 가능</li>\n</ul>\n<h2>함수 기반 인덱스</h2>\n<p>함수나 표현식의 결과값을 인덱스로 생성하는 방식</p>\n<h3>활용 사례</h3>\n<h4>1. 문자열 처리</h4>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 대소문자 구분 없는 검색</span>\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> idx_name <span class=\"token keyword\">ON</span> table_name <span class=\"token punctuation\">(</span>LOWER<span class=\"token punctuation\">(</span>column_name<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">-- 이메일 도메인 검색</span>\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> idx_email <span class=\"token keyword\">ON</span> <span class=\"token keyword\">user</span> <span class=\"token punctuation\">(</span>SUBSTRING<span class=\"token punctuation\">(</span>email<span class=\"token punctuation\">,</span> <span class=\"token string\">'@'</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h4>2. 날짜 처리</h4>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- 월별/연도별 검색 최적화</span>\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> idx_month <span class=\"token keyword\">ON</span> <span class=\"token keyword\">table</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">MONTH</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">date</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> idx_year <span class=\"token keyword\">ON</span> <span class=\"token keyword\">table</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">YEAR</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">date</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h4>3. 해시값 검색</h4>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">CREATE</span> <span class=\"token keyword\">INDEX</span> idx_hash <span class=\"token keyword\">ON</span> <span class=\"token keyword\">table</span> <span class=\"token punctuation\">(</span>MD5<span class=\"token punctuation\">(</span><span class=\"token keyword\">column</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>주의사항</h3>\n<ol>\n<li>실행 계획 확인 필수</li>\n<li>데이터 타입 명확히 지정\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">-- double 타입 예시</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span> <span class=\"token keyword\">WHERE</span> <span class=\"token punctuation\">(</span>col1 <span class=\"token operator\">+</span> col2<span class=\"token punctuation\">)</span> <span class=\"token operator\">&lt;</span> CAST<span class=\"token punctuation\">(</span><span class=\"token number\">1000</span> <span class=\"token keyword\">AS</span> <span class=\"token keyword\">DOUBLE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>표현식 결과 타입 확인 방법:\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">MONTH</span><span class=\"token punctuation\">(</span><span class=\"token string\">'2024-01-01'</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">AS</span> EXPR_RESULT<span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n</ol>\n<h3>제한사항</h3>\n<ul>\n<li>일반 인덱스보다 추가 계산 비용 발생</li>\n<li>Non-Deterministic Function 사용 불가</li>\n<li>공간/전문검색 인덱스 미지원</li>\n<li>Primary Key에 표현식 포함 불가</li>\n</ul>\n<h2>에러 핸들링</h2>\n<h3>에러 유형</h3>\n<ol>\n<li>Global Error (1-999)</li>\n<li>Server Error (1000-1999, 3000+)</li>\n<li>Client Error (2000-2999)</li>\n</ol>\n<h3>MySQL 에러 구성요소</h3>\n<h4>1. Error No</h4>\n<ul>\n<li>Global Error: 1-999</li>\n<li>Server Error: 1000-1999, 3000+</li>\n<li>Client Error: 2000-2999</li>\n</ul>\n<h4>2. SQLState</h4>\n<p>5자리 문자열 구조:</p>\n<ul>\n<li>00: 성공</li>\n<li>01: 경고</li>\n<li>02: No Data</li>\n<li>HY: 벤더 의존적 상태값</li>\n<li>기타: 에러</li>\n</ul>\n<h4>3. Error Message</h4>\n<ul>\n<li>사람이 읽을 수 있는 형태</li>\n<li>버전별로 변경될 수 있어 에러 처리에 사용 지양</li>\n</ul>\n<h3>에러 처리 권장사항</h3>\n<ul>\n<li>SQLState 기반 처리 권장 (ANSI SQL 표준)</li>\n<li>HY 상태값은 ErrorNo와 함께 사용</li>\n<li>Error Message 기반 처리 지양</li>\n</ul>\n<h2>LEFT JOIN 주의사항 &#x26; 튜닝</h2>\n<h3>예시 데이터</h3>\n<table>\n<thead>\n<tr>\n<th>테이블명</th>\n<th>전체 데이터</th>\n<th>상세</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>user</td>\n<td>30,000 rows</td>\n<td>-</td>\n</tr>\n<tr>\n<td>user_coupon</td>\n<td>100,000 rows</td>\n<td>coupon_id=1: 1,000</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>coupon_id=2: 1,000</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td>coupon_id=3: 1,000</td>\n</tr>\n</tbody>\n</table>\n<h3>JOIN 동작 방식 비교</h3>\n<h4>데이터 연결</h4>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> <span class=\"token keyword\">user</span> u\n<span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">JOIN</span> user_coupon uc \n    <span class=\"token keyword\">ON</span> u<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> uc<span class=\"token punctuation\">.</span>user_id \n    <span class=\"token operator\">AND</span> uc<span class=\"token punctuation\">.</span>coupon_id <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>결과: 30,000 rows (0.04 sec)</li>\n<li>역할: 데이터 연결</li>\n</ul>\n<h4>데이터 필터링</h4>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span>\n<span class=\"token keyword\">FROM</span> <span class=\"token keyword\">user</span> u\n<span class=\"token keyword\">LEFT</span> <span class=\"token keyword\">JOIN</span> user_coupon uc \n    <span class=\"token keyword\">ON</span> u<span class=\"token punctuation\">.</span>id <span class=\"token operator\">=</span> uc<span class=\"token punctuation\">.</span>user_id\n<span class=\"token keyword\">WHERE</span> uc<span class=\"token punctuation\">.</span>coupon_id <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>결과: 1,000 rows (0.00 sec)</li>\n<li>역할: 데이터 필터링</li>\n<li>특징: INNER JOIN과 동일한 효과</li>\n</ul>\n<h3>실행 계획 특징</h3>\n<p><strong>LEFT JOIN</strong>:</p>\n<ul>\n<li>FROM 테이블 먼저 full scan</li>\n<li>이후 참조 데이터 검색</li>\n</ul>\n<p><strong>INNER JOIN</strong>:</p>\n<ul>\n<li>Optimizer가 참조 테이블 먼저 검색</li>\n<li>필터링 후 데이터 연결</li>\n</ul>\n<h3>최적화 팁</h3>\n<ul>\n<li>COUNT(*) 쿼리에서 불필요한 JOIN 제거</li>\n<li>JOIN 조건은 ON절에 명시 (IS NULL 조건 제외)</li>\n<li>LEFT JOIN과 INNER JOIN의 특성을 고려하여 선택</li>\n</ul>\n<h2>Prepared Statement</h2>\n<h3>기본 사용법</h3>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\">pstmt <span class=\"token operator\">=</span> connection<span class=\"token punctuation\">.</span><span class=\"token function\">prepareStatement</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"SELECT * FROM matt WHERE id=?\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\npstmt<span class=\"token punctuation\">.</span><span class=\"token function\">setInt</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">1234</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\nrs <span class=\"token operator\">=</span> pstmt<span class=\"token punctuation\">.</span><span class=\"token function\">executeQuery</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>장단점</h3>\n<h4>장점</h4>\n<ul>\n<li>SQL Injection 방지</li>\n<li>쿼리 파싱 비용 감소</li>\n</ul>\n<h4>단점</h4>\n<ul>\n<li>메모리 사용량 증가</li>\n<li>MySQL에서는 Parse Tree만 캐시 (실행 계획 제외)</li>\n<li>Connection 단위 캐시</li>\n</ul>\n<h3>캐시 방식</h3>\n<ol>\n<li>Client Side PreparedStatement</li>\n<li>Server Side PreparedStatement</li>\n</ol>\n<blockquote>\n<p><a href=\"https://stackoverflow.com/questions/32286518/whats-the-difference-between-cacheprepstmts-and-useserverprepstmts-in-mysql-jdb\" target=\"_blank\" rel=\"nofollow\">상세 비교 참조</a></p>\n</blockquote>\n<h3>Server Side 사용 시 고려사항</h3>\n<p>메모리 사용량 예시:</p>\n<ul>\n<li>전체 커넥션: 5,000개</li>\n<li>필요 쿼리 패턴: 100개</li>\n<li>필요 PS 객체: 500,000개</li>\n<li>기본 max_prepared_stmt_count: 16,382</li>\n</ul>\n<h3>사용 권장사항</h3>\n<ol>\n<li>\n<p>쿼리 복잡도에 따른 선택:</p>\n<ul>\n<li>단순 쿼리: PreparedStatement 미사용 권장</li>\n<li>복잡한 쿼리: PreparedStatement 사용 권장</li>\n</ul>\n</li>\n<li>\n<p>리소스 고려:</p>\n<ul>\n<li>AWS RDS 환경(db.t3.medium, db.r5.large)에서는 메모리가 제한적</li>\n<li>CPU vs 메모리 사용량 균형 필요</li>\n</ul>\n</li>\n</ol>\n<h3>주의사항</h3>\n<ul>\n<li>Server-side PreparedStatement의 부작용 주의</li>\n<li>ORM 애플리케이션의 단순 쿼리 특성 고려</li>\n<li>성능 향상이 제한적일 수 있음</li>\n<li>max_prepared_stmt_count 부족 시 효과 감소</li>\n</ul>\n<h2>SQL 문장의 가독성 향상</h2>\n<h3>1. DISTINCT 사용법</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">/* 지양할 형태 */</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">DISTINCT</span> <span class=\"token punctuation\">(</span><span class=\"token keyword\">column</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/* 권장 형태 */</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token keyword\">DISTINCT</span> <span class=\"token keyword\">column</span> <span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span><span class=\"token punctuation\">;</span></code></pre></div>\n<h3>2. LEFT JOIN 작성 규칙</h3>\n<ul>\n<li>조인 대상 테이블 조건은 ON절에 명시</li>\n<li>WHERE절 사용 시 INNER JOIN과 동일 효과</li>\n<li>불필요한 LEFT JOIN 제거 (단순 SELECT/COUNT 등)</li>\n</ul>\n<h3>3. ORDER BY와 LIMIT</h3>\n<ul>\n<li>ORDER BY 없는 LIMIT 사용 지양</li>\n<li>페이지네이션 시 반드시 ORDER BY 포함</li>\n</ul>\n<h3>4. FULL Group By 형식</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">/* 지양할 형태 */</span>\n<span class=\"token keyword\">SELECT</span> column1<span class=\"token punctuation\">,</span> column2 \n<span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span> \n<span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span> column1<span class=\"token punctuation\">;</span>\n\n<span class=\"token comment\">/* 권장 형태 */</span>\n<span class=\"token keyword\">SELECT</span> column1<span class=\"token punctuation\">,</span> <span class=\"token function\">SUM</span><span class=\"token punctuation\">(</span>column2<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span> \n<span class=\"token keyword\">FROM</span> <span class=\"token keyword\">table</span> \n<span class=\"token keyword\">GROUP</span> <span class=\"token keyword\">BY</span> column1<span class=\"token punctuation\">;</span></code></pre></div>\n<h3>5. 논리 연산자 사용</h3>\n<ul>\n<li>AND/OR 조건 혼용 시 괄호 필수</li>\n</ul>\n<h3>6. COUNT 사용법</h3>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token comment\">/* 지양할 형태 */</span>\n<span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">SUM</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span>pk_col<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span> <span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span>not_null_col<span class=\"token punctuation\">)</span>\n\n<span class=\"token comment\">/* 권장 형태 */</span>\n<span class=\"token function\">COUNT</span><span class=\"token punctuation\">(</span><span class=\"token operator\">*</span><span class=\"token punctuation\">)</span></code></pre></div>","fields":{"category":"lecture"},"frontmatter":{"title":"Real MySQL","summary":"Real MySQL 강의 정리","date":"2024.12.31.","tags":["lecture"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAABjElEQVR42u2U207CQBCG+8g+go9hYvTCExeoGAWDB2JQsIDFghwUiJwKrXLoAkVUvPidWUAw8cIE4pUXf3e7s/v905lmlZ5dwyKl/AMXC3REfXFAhomWgX5nPqjSIchwYCEQTGBp2YtS8REv3Qm0Do5326zaeBypJ+j9RyAFPwioJ+/hP9cl8K1vwm5U5YHhi4W3nol3h0bHJFl4pZGNBrTuiJrUt082KkX4Azo8xzcIhu9kBmo0De9pHFEtg0TyAXriHvHbrDSOxTO4UlNIp3MQTQNtNm+Pgc2nKjTamM8XcKNlkcsVpI78GtZdIRyQyfZeBKtbIbgPY9h0q3DtRxCOpOAjQzU2Mj670FEghsKHr65TaBGYg+x4QtnG9ax05lpxWdidY9y4SUY8t2mNy1MpF9GwKlCezQplEsbaTghbuypWNi7h8Wl4pfpMOu5Qc7hOfVGXf8PXupiKG8kxhR/sxkUWY/Hmrj3t4uz8V//hrNNsx/4vhz8CitE9MNKcQIY0n8owjBLsliX1CTPZynf2Ss39AAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/a229594a2de7c0ed63d877869e75fd38/d0859/common.png","srcSet":"/static/a229594a2de7c0ed63d877869e75fd38/f1689/common.png 270w,\n/static/a229594a2de7c0ed63d877869e75fd38/42fd3/common.png 540w,\n/static/a229594a2de7c0ed63d877869e75fd38/d0859/common.png 1080w","sizes":"(min-width: 1080px) 1080px, 100vw"},"sources":[{"srcSet":"/static/a229594a2de7c0ed63d877869e75fd38/7e223/common.webp 270w,\n/static/a229594a2de7c0ed63d877869e75fd38/5cfb6/common.webp 540w,\n/static/a229594a2de7c0ed63d877869e75fd38/941f9/common.webp 1080w","type":"image/webp","sizes":"(min-width: 1080px) 1080px, 100vw"}]},"width":1080,"height":1080}},"publicURL":"/static/a229594a2de7c0ed63d877869e75fd38/common.png"}}}}]}},"pageContext":{"slug":"/lecture/Real-Mysql","category":"lecture"}},"staticQueryHashes":["2433549356","3142469158"],"slicesMap":{}}