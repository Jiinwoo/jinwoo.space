{"componentChunkName":"component---src-templates-post-template-tsx","path":"/TIL/2024-11-24-dil/","result":{"data":{"allMarkdownRemark":{"edges":[{"node":{"html":"<p>메시지 큐 장점</p>\n<blockquote>\n<ul>\n<li>결합도 완화</li>\n<li>규모 확장성 완화</li>\n<li>가용성 개선</li>\n<li>성능 개선 (비동기 처리)</li>\n</ul>\n</blockquote>\n<p>메시지 큐 단점</p>\n<blockquote>\n<ul>\n<li>시스템 복잡성 증가</li>\n<li>일관성 보장 어려움</li>\n<li>성능 오버헤드</li>\n<li>DLQ 나 처리 실패 시나리오 처리</li>\n<li>모니터링 및 디버깅 어려움</li>\n</ul>\n</blockquote>\n<p>이번 장에서는</p>\n<ul>\n<li>데이터 장기 보관</li>\n<li>메시지 반복 소비\n기능을 가진 분산 메시지 큐를 설계해 볼 것.</li>\n</ul>\n<h1>문제 이해 및 설계 범위 확정</h1>\n<h3>기능 요구사항</h3>\n<ul>\n<li>생산자는 메시지 큐에 메시지 보냄</li>\n<li>소비자는 메시지 큐에서 메시지 가져옴</li>\n<li>메시지는 반복적으로 수신할 수도 있고 단 한 번만 수신하도록 할 수도 있어야 함</li>\n<li>오래된 이력 데이터는 삭제될 수 있음.</li>\n<li>메시지 크기는 킬로바이트 수준</li>\n<li>메시지는 생산된 순서대로 소비자에게 전달.</li>\n<li>메시지 전달 방식\n<ul>\n<li>최소 한 번</li>\n<li>최대 한 번</li>\n<li>정확히 한 번</li>\n</ul>\n</li>\n</ul>\n<h3>비기능 요구사항</h3>\n<ul>\n<li>높은 대역폭과 낮은 전송 지연 가운데 하나를 설정</li>\n<li>규모 확장성. 수백만 개의 메시지를 처리할 수 있어야 함.</li>\n<li>지속성 및 내구성. 데이터는 디스크에 지속적으로 보관되어야 하며 여러 노드에 복제되어야 함.</li>\n</ul>\n<h3>전통적 메시지 큐와 다른점</h3>\n<ul>\n<li>데이터 장기 보관</li>\n<li>메시지 전달 순서 보존</li>\n</ul>\n<h1>개략적 설계안 제시 및 동의 구하기</h1>\n<h2>일대일 모델</h2>\n<ul>\n<li>각 메시지는 한 소비자만 가져갈 수 있다.</li>\n<li>ACK 를 받은 메시지는 삭제</li>\n</ul>\n<h2>발행/구독 모델</h2>\n<ul>\n<li>“토픽” 이라는 개념이 등장.</li>\n</ul>\n<blockquote>\n<ul>\n<li>RabbitMQ 에서는 Topic Exchange 로 라우팅 방식을 결정</li>\n</ul>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">> 예를 들어 Order Server 에서 order.created 라는 토픽으로 메시지를 보내면\n> Payment Server 에서는 order.created, order.* 등의 패턴으로 큐를 만들어서 메시지를 받을 수 있음.</code></pre></div>\n<blockquote>\n<ul>\n<li>Kafka 에서는 Topic 이라는 개념이 있음. Topic 은 여러 파티션으로 나뉘어져 있음.</li>\n</ul>\n</blockquote>\n<h2>토픽, 파티션, 브로커</h2>\n<p>토픽에 보관되는 양이 많아지면? -> 파티션, 즉 샤딩기법을 활용\n토픽을 여러 파티션으로 나누어 모든 파티션에 균등하게 분배.</p>\n<p>파티션을 유지하는 서버는 브로커라고 부름.</p>\n<p>파티션을 균등하게 분배하는 것 -> 높은 규모의 확장성,</p>\n<p>토픽의 용량을 확장하고 싶으면 파티션 개수를 늘리면 됨.</p>\n<p>각 토픽의 파티션은 FIFO 큐 처럼 동작. -> 같은 파티션 안에서는 메시지 순서가 유지됨.</p>\n<p>파티션 내에서 메시지 위치는 오프셋(offset) 이라 불림.</p>\n<p>메시지는 사용자ID 같은 키를 붙일 수 있는데, 같은 키를 가진 메시지는 같은 파티션으로 보내짐.</p>\n<p>키가 없으면 무작위 파티션을 선택.</p>\n<p>소비자는 하나 이상의 파티션에서 데이터를 가져옴.</p>\n<h2>소비자 그룹</h2>\n<p>하나의 소비자 그룹은 여러 토픽을 구독할 수 있고 별도로 오프셋을 관리함.</p>\n<blockquote>\n<p>다른 소비자 그룹이 존재하고 서로 다른 소비자 그룹이 같은 파티션을 소비하더라도\n별도의 오프셋으로 관리하기 때문에 데이터를 읽는데 영향을 주지 않음.</p>\n</blockquote>\n<p>같은 그룹 내 소비자는 메시지를 병렬로 소비가능.</p>\n<p>여기서 문제가 발생하는 부분: 병렬로 소비하면 대역폭 측면에서는 좋지만 메시지 순서가 보장되지 않음.</p>\n<p>제약사항: 어떤 파티션은 하나의 소비자 그룹안에서는 오직 하나의 소비자만 소비하도록 제한.</p>\n<blockquote>\n<p><a href=\"https://stackoverflow.com/questions/21363302/rabbitmq-message-order-of-delivery\" target=\"_blank\" rel=\"nofollow\">RabbitMQ는 순서를 보장할 수 없을까?</a></p>\n<p>Kafka 도 파티션내에서만 유지되기 때문에 적절한 파티셔닝을 해야 순서가 보장됨.</p>\n</blockquote>\n<h1>상세 설계</h1>\n<ol>\n<li>데이터 장기 보관</li>\n<li>높은 대역폭</li>\n</ol>\n<p>만족하는 다음의 결정.</p>\n<ul>\n<li>회전 디스크의 높은 순차 탐색 성능, 적극적 디스크 캐시 전략을 사용가능한 디스크 기반 자료구조 선택</li>\n<li>생산자로부터 소비자에게 전달되는 순간까지 아무 수정 없는 메시지 자료구조. (메시지 복사에 드는 비용을 최소화)</li>\n<li>일괄 처리(Batching) 우선하는 시스템 설계. 소규모 I/O 작업을 줄이기 위해 메시지를 배치로 전송, 소비자도 배치로 메시지를 가져옴.</li>\n</ul>\n<h3>데이터 저장소</h3>\n<p>고려사항</p>\n<ul>\n<li>읽기와 쓰기가 빈번함.</li>\n<li>갱신 / 삭제는 이루어지지 않음.</li>\n<li>순차적인 읽기/쓰기가 대부분.</li>\n</ul>\n<ol>\n<li>\n<p>데이터베이스:<br>\n읽기 쓰기가 동시에 대규모로 빈번하게 발생. -> 데이터베이스는 부하가 커짐.</p>\n</li>\n<li>\n<p>쓰기 우선 로그(Write-Ahead Log, WAL)<br>\n새로운 항목이 추가되기만 하는 일반 파일. Mysql 의 redo log, 아파치 주키퍼가 활용중\nWAL에 대한 접근 패턴은 읽기/쓰기 전부 순차적. 디스크는 아주 좋은 성능에 가격도 저렴.</p>\n</li>\n</ol>\n<p>파일은 무한정 커질 수 없으니 세그먼트(segment)로 나누어 관리.\n활성 세그먼트, 비활성 세그먼트가 존재하며 데이터의 추가는 활성 세그먼트에만 이루어지고\n해당 활성 세그먼트의 크기가 일정 한계에 도달하면 새 활성 세그먼트를 만들어 새로운 메시지를 수용.\n비활성 세그먼트는 보관 기한이 만료되거나 용량 한계에 도달하면 삭제가능.</p>\n<p>성능 유의사항.\n회전식 디스크가 느리다는 것은 접근 패턴이 무작위일때.</p>\n<h3>메시지 자료구조</h3>\n<ul>\n<li>메시지 키\n<ul>\n<li>파티션을 결정하는데 사용가능.</li>\n</ul>\n</li>\n<li>메시지 값</li>\n<li>토픽</li>\n<li>파티션</li>\n<li>오프셋</li>\n<li>타임 스탬프</li>\n<li>크기</li>\n<li>CRC (순환 중복 검사)</li>\n</ul>\n<p>WAL 로 오프셋, 파티션 등등을 추가해서 저장하며 한번 저장한 뒤로는 수정 X</p>\n<h3>일괄처리</h3>\n<p>장점</p>\n<ol>\n<li>I/O 작업을 줄임</li>\n<li>여러 메시지를 한 번에 로그에 기록 -> 큰 규모의 순차 쓰기 연산 -> 운영체제의 디스크 캐시에서 큰 규모의 연속된 공간점유 -> 높은 디스크 접근 대역폭</li>\n</ol>\n<p>높은 대역폭과 낮은 응답 지연은 동시에 달성하기 힘듬.</p>\n<h2>생산자 측 작업 흐름</h2>\n<h3>프로세스 1</h3>\n<p>가정: 생산자가 특정 파티션에 메시지를 보낸다고 가정.</p>\n<p>문제: 어느 브로커에 메시지를 보내야 할지 결정해야 함.</p>\n<p>해결: 라우팅 계층 도입. 라우팅 계층은 적절한 브로커를 선택하고 메시지를 전달.</p>\n<p>이 때 적절한 브로커는 리더 브로커(Leader Broker) 라고 부름.</p>\n<p>리더 브로커는 우선 메시지를 받고 해당 리더를 따르는 다른 브로커는 리더 브로커로부터 데이터를 받음.</p>\n<p>‘충분한’ 수의 사본이 동기화되면 리더는 데이터를 디스크에 기록. 기록이 끝나면 생산자에게 회신</p>\n<p>리더와 사본이 필요한 이유? 장애 감내(fault tolerance)를 위해.</p>\n<h3>프로세스 2</h3>\n<p>프로세스 1의 문제점: 라우팅 계층은 네트워크 오버헤드가 발생, 일괄처리가 불가능한 부분</p>\n<p>해결: 라우팅 계층을 생산자에게 두어서 생산자가 직접 브로커에게 메시지를 보내도록 함.</p>\n<p>장점: 전송 지연이 줄어듬, 어느 파티션에 보내야 하는 결정 로직을 가질 수 있음, 일괄 처리가능.</p>\n<h2>소비자 측 작업 흐름</h2>\n<p>소비자는 특정 파티션의 오프셋을 주고 해당 위치로부터 이벤트를 묶어 가져옴.</p>\n<h3>푸시 / 풀</h3>\n<p>Push</p>\n<p>장점:</p>\n<ul>\n<li>낮은 지연 (받는 즉시 client 에게 전달)</li>\n</ul>\n<p>단점:</p>\n<ul>\n<li>소비자가 처리할 수 없을 정도로 빠르게 메시지가 들어오면 부하 증가</li>\n<li>생산자가 데이터 전송 속도를 좌우하므로 소비자는 그에 맞는 컴퓨팅 자원을 준비해야함.</li>\n</ul>\n<p>Pull</p>\n<p>장점:</p>\n<ul>\n<li>어떤 소비자는 실시간으로 어떤 소비자는 Batch 로 처리하도록 조절 가능.</li>\n</ul>\n<p>단점:</p>\n<ul>\n<li>메시지가 없어도 계속 데이터 요구, 즉 소비자측 컴퓨팅 자원낭비 발생.</li>\n</ul>\n<p>대부분 Pull 방식을 사용.</p>","fields":{"category":"TIL"},"frontmatter":{"title":"대규모 시스템 설계 기초 2 TIL - 1","summary":"4장 분산 메시지 큐","date":"2024.11.24.","tags":["study","TIL"],"thumbnail":{"childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAABjElEQVR42u2U207CQBCG+8g+go9hYvTCExeoGAWDB2JQsIDFghwUiJwKrXLoAkVUvPidWUAw8cIE4pUXf3e7s/v905lmlZ5dwyKl/AMXC3REfXFAhomWgX5nPqjSIchwYCEQTGBp2YtS8REv3Qm0Do5326zaeBypJ+j9RyAFPwioJ+/hP9cl8K1vwm5U5YHhi4W3nol3h0bHJFl4pZGNBrTuiJrUt082KkX4Azo8xzcIhu9kBmo0De9pHFEtg0TyAXriHvHbrDSOxTO4UlNIp3MQTQNtNm+Pgc2nKjTamM8XcKNlkcsVpI78GtZdIRyQyfZeBKtbIbgPY9h0q3DtRxCOpOAjQzU2Mj670FEghsKHr65TaBGYg+x4QtnG9ax05lpxWdidY9y4SUY8t2mNy1MpF9GwKlCezQplEsbaTghbuypWNi7h8Wl4pfpMOu5Qc7hOfVGXf8PXupiKG8kxhR/sxkUWY/Hmrj3t4uz8V//hrNNsx/4vhz8CitE9MNKcQIY0n8owjBLsliX1CTPZynf2Ss39AAAAAElFTkSuQmCC"},"images":{"fallback":{"src":"/static/a229594a2de7c0ed63d877869e75fd38/d0859/common.png","srcSet":"/static/a229594a2de7c0ed63d877869e75fd38/f1689/common.png 270w,\n/static/a229594a2de7c0ed63d877869e75fd38/42fd3/common.png 540w,\n/static/a229594a2de7c0ed63d877869e75fd38/d0859/common.png 1080w","sizes":"(min-width: 1080px) 1080px, 100vw"},"sources":[{"srcSet":"/static/a229594a2de7c0ed63d877869e75fd38/7e223/common.webp 270w,\n/static/a229594a2de7c0ed63d877869e75fd38/5cfb6/common.webp 540w,\n/static/a229594a2de7c0ed63d877869e75fd38/941f9/common.webp 1080w","type":"image/webp","sizes":"(min-width: 1080px) 1080px, 100vw"}]},"width":1080,"height":1080}},"publicURL":"/static/a229594a2de7c0ed63d877869e75fd38/common.png"}}}}]}},"pageContext":{"slug":"/TIL/2024-11-24-dil","category":"TIL"}},"staticQueryHashes":["2433549356","3142469158"],"slicesMap":{}}