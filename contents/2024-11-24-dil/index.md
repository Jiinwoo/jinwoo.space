---
date: '2024-11-24'
title: "대규모 시스템 설계 기초 2 DIL - 1"
categories: [ 'study', "DIL" ]
summary: "4장 분산 메시지 큐"
thumbnail: '../common.png'
---


메시지 큐 장점

- 결합도 완화
- 규모 확장성 완화
- 가용성 개선
- 성능 개선 (비동기 처리)

메시지 큐 단점
> - 시스템 복잡성 증가
> - 일관성 보장 어려움
> - 성능 오버헤드
> - DLQ 나 처리 실패 시나리오 처리
> - 모니터링 및 디버깅 어려움

이번 장에서는

- 데이터 장기 보관
- 메시지 반복 소비
  기능을 가진 분산 메시지 큐를 설계해 볼 것.

# 문제 이해 및 설계 범위 확정

### 기능 요구사항

- 생산자는 메시지 큐에 메시지 보냄
- 소비자는 메시지 큐에서 메시지 가져옴
- 메시지는 반복적으로 수신할 수도 있고 단 한 번만 수신하도록 할 수도 있어야 함
- 오래된 이력 데이터는 삭제될 수 있음.
- 메시지 크기는 킬로바이트 수준
- 메시지는 생산된 순서대로 소비자에게 전달.
- 메시지 전달 방식
    - 최소 한 번
    - 최대 한 번
    - 정확히 한 번

### 비기능 요구사항

- 높은 대역폭과 낮은 전송 지연 가운데 하나를 설정
- 규모 확장성. 수백만 개의 메시지를 처리할 수 있어야 함.
- 지속성 및 내구성. 데이터는 디스크에 지속적으로 보관되어야 하며 여러 노드에 복제되어야 함.

### 전통적 메시지 큐와 다른점

- 데이터 장기 보관
- 메시지 전달 순서 보존

# 개략적 설계안 제시 및 동의 구하기

## 일대일 모델

- 각 메시지는 한 소비자만 가져갈 수 있다.
- ACK 를 받은 메시지는 삭제

## 발행/구독 모델

- "토픽" 이라는 개념이 등장.

> - RabbitMQ 에서는 Topic Exchange 로 라우팅 방식을 결정
    > 예를 들어 Order Server 에서 order.created 라는 토픽으로 메시지를 보내면
    > Payment Server 에서는 order.created, order.* 등의 패턴으로 큐를 만들어서 메시지를 받을 수 있음.
> - Kafka 에서는 Topic 이라는 개념이 있음. Topic 은 여러 파티션으로 나뉘어져 있음.

## 토픽, 파티션, 브로커

토픽에 보관되는 양이 많아지면? -> 파티션, 즉 샤딩기법을 활용
토픽을 여러 파티션으로 나누어 모든 파티션에 균등하게 분배.

파티션을 유지하는 서버는 브로커라고 부름.

파티션을 균등하게 분배하는 것 -> 높은 규모의 확장성,

토픽의 용량을 확장하고 싶으면 파티션 개수를 늘리면 됨.

각 토픽의 파티션은 FIFO 큐 처럼 동작. -> 같은 파티션 안에서는 메시지 순서가 유지됨.

파티션 내에서 메시지 위치는 오프셋(offset) 이라 불림.

메시지는 사용자ID 같은 키를 붙일 수 있는데, 같은 키를 가진 메시지는 같은 파티션으로 보내짐.

키가 없으면 무작위 파티션을 선택.

소비자는 하나 이상의 파티션에서 데이터를 가져옴.

## 소비자 그룹

하나의 소비자 그룹은 여러 토픽을 구독할 수 있고 별도로 오프셋을 관리함.
> 다른 소비자 그룹이 존재하고 서로 다른 소비자 그룹이 같은 파티션을 소비하더라도
> 별도의 오프셋으로 관리하기 때문에 데이터를 읽는데 영향을 주지 않음.

같은 그룹 내 소비자는 메시지를 병렬로 소비가능.

여기서 문제가 발생하는 부분: 병렬로 소비하면 대역폭 측면에서는 좋지만 메시지 순서가 보장되지 않음.

제약사항: 어떤 파티션은 하나의 소비자 그룹안에서는 오직 하나의 소비자만 소비하도록 제한.
> [RabbitMQ는 순서를 보장할 수 없을까?](https://stackoverflow.com/questions/21363302/rabbitmq-message-order-of-delivery)
>
> Kafka 도 파티션내에서만 유지되기 때문에 적절한 파티셔닝을 해야 순서가 보장됨.

# 상세 설계

1. 데이터 장기 보관
2. 높은 대역폭

만족하는 다음의 결정.

- 회전 디스크의 높은 순차 탐색 성능, 적극적 디스크 캐시 전략을 사용가능한 디스크 기반 자료구조 선택
- 생산자로부터 소비자에게 전달되는 순간까지 아무 수정 없는 메시지 자료구조. (메시지 복사에 드는 비용을 최소화)
- 일괄 처리(Batching) 우선하는 시스템 설계. 소규모 I/O 작업을 줄이기 위해 메시지를 배치로 전송, 소비자도 배치로 메시지를 가져옴.

### 데이터 저장소

고려사항

- 읽기와 쓰기가 빈번함.
- 갱신 / 삭제는 이루어지지 않음.
- 순차적인 읽기/쓰기가 대부분.

1. 데이터베이스

   읽기 쓰기가 동시에 대규모로 빈번하게 발생. -> 데이터베이스는 부하가 커짐.

2. 쓰기 우선 로그(Write-Ahead Log, WAL)
   새로운 항목이 추가되기만 하는 일반 파일. Mysql 의 redo log, 아파치 주키퍼가 활용중
   WAL에 대한 접근 패턴은 읽기/쓰기 전부 순차적. 디스크는 아주 좋은 성능에 가격도 저렴.

파일은 무한정 커질 수 없으니 세그먼트(segment)로 나누어 관리.
활성 세그먼트, 비활성 세그먼트가 존재하며 데이터의 추가는 활성 세그먼트에만 이루어지고
해당 활성 세그먼트의 크기가 일정 한계에 도달하면 새 활성 세그먼트를 만들어 새로운 메시지를 수용.
비활성 세그먼트는 보관 기한이 만료되거나 용량 한계에 도달하면 삭제가능.

성능 유의사항.
회전식 디스크가 느리다는 것은 접근 패턴이 무작위일때.

### 메시지 자료구조

- 메시지 키
    - 파티션을 결정하는데 사용가능.
- 메시지 값
- 토픽
- 파티션
- 오프셋
- 타임 스탬프
- 크기
- CRC (순환 중복 검사)

WAL 로 오프셋, 파티션 등등을 추가해서 저장하며 한번 저장한 뒤로는 수정 X

### 일괄처리

장점

1. I/O 작업을 줄임
2. 여러 메시지를 한 번에 로그에 기록 -> 큰 규모의 순차 쓰기 연산 -> 운영체제의 디스크 캐시에서 큰 규모의 연속된 공간점유 -> 높은 디스크 접근 대역폭

높은 대역폭과 낮은 응답 지연은 동시에 달성하기 힘듬.



## 생산자 측 작업 흐름

### 프로세스 1
가정: 생산자가 특정 파티션에 메시지를 보낸다고 가정.

문제: 어느 브로커에 메시지를 보내야 할지 결정해야 함.

해결: 라우팅 계층 도입. 라우팅 계층은 적절한 브로커를 선택하고 메시지를 전달.

이 때 적절한 브로커는 리더 브로커(Leader Broker) 라고 부름. 

리더 브로커는 우선 메시지를 받고 해당 리더를 따르는 다른 브로커는 리더 브로커로부터 데이터를 받음.

'충분한' 수의 사본이 동기화되면 리더는 데이터를 디스크에 기록. 기록이 끝나면 생산자에게 회신

리더와 사본이 필요한 이유? 장애 감내(fault tolerance)를 위해.


### 프로세스 2

프로세스 1의 문제점: 라우팅 계층은 네트워크 오버헤드가 발생, 일괄처리가 불가능한 부분

해결: 라우팅 계층을 생산자에게 두어서 생산자가 직접 브로커에게 메시지를 보내도록 함.

장점: 전송 지연이 줄어듬, 어느 파티션에 보내야 하는 결정 로직을 가질 수 있음, 일괄 처리가능.


## 소비자 측 작업 흐름

소비자는 특정 파티션의 오프셋을 주고 해당 위치로부터 이벤트를 묶어 가져옴.

### 푸시 / 풀

Push

장점: 
- 낮은 지연 (받는 즉시 client 에게 전달)

단점: 
- 소비자가 처리할 수 없을 정도로 빠르게 메시지가 들어오면 부하 증가
- 생산자가 데이터 전송 속도를 좌우하므로 소비자는 그에 맞는 컴퓨팅 자원을 준비해야함. 


Pull

장점:
- 어떤 소비자는 실시간으로 어떤 소비자는 Batch 로 처리하도록 조절 가능.

단점:
- 메시지가 없어도 계속 데이터 요구, 즉 소비자측 컴퓨팅 자원낭비 발생.

대부분 Pull 방식을 사용.







