---
date: '2024-11-09'
title: "대규모 시스템 설계 기초 2 DIL"
tags: [ 'study', "DIL" ]
summary: "2장 주변친구"
thumbnail: '../../common.png'
---

목표: 앱 사용자 가운데 위치 정보 접근 권한을 허락한 사용자에 한해 인근의 친구 목록을 보여주는 시스템 구축

1장에서 배운 근접성 서비스와의 차이점: 위치정보의 정적이냐 동적이냐의 차이

# 문제 이해 및 설계 범위 확정

- 어느정도 가까워야 하나? -> 기본적으로 8km 이내, 하지만 사용자가 설정 가능해야함.
- 거리는 사용자간의 직선거리로 계산 (사용자간의 디테일한 거리 계산은 불필요)
- 앱사용자는 10억명, 이 기능을 사용하는 유저는 10%라고 가정
- 사용자의 이동 기록은 보관. 추후 기계 학습을 위해
- 친구 관계에 있는 사용자가 10분 이상 비활성화 시 지도상에서 표시하지 않도록 함.
- GDPR, CCPA 은 일단 생략.
- 평균적으로 한 사용자는 400명의 친구를 갖는다 가정
- 친구 위치는 30초마다 갱신

## 기능 요구사항

- 모바일 앱에서 주변 친구를 확인 가능.
- 주변 친구 목록에는 친구까지의 거리, 마지막 갱신시각이 함께 표시

## 비기능 요구사항.

- 주변 친구의 위치가 갱신되는 시간이 너무 오랜시간이 걸리지 않아야 함.
- 전반적으로 시스템이 안정적이어야 하지만 때론 몇개의 데이터가 유실되어도 괜찮음.
- 강한 일광성을 지원하는 데이터베이스는 필요 없음. 결과적 일관성만 지원하면 됨.

> 강한 일관성, 결과적 일관성 데이터베이스 조금더 공부해보기

# 개략적 설계안 제시 및 동의 구하기

## 개략적 설계안

### P2P 방식

1. 사용자는 근방의 모든 활성 상태 친구의 새 위치정보를 수신해야함.
2. P2P 방식으로 해결가능한
   단점: 통신 연결상태가 좋지않은경우, 사용할 수 있는 전력도 충분치 않음.

### 공용 백엔드 서버 방식

1. 모든 사용자의 위치 변화를 수신해야함.
2. 위치 변화를 수신할 때마다 해당 사용자의 모든 활성 상태 친구를 찾아서 변경내역을 전파.
3. 전파할 때 특정 임계치 보다 먼 경우에는 변경 내역을 전달하지 않음.

천만명이 30초마다 갱신한다고 했을 때 334,000번 위치 갱신 API 호출이 발생, 평균 400명의 친구이며 그 중 10%만 활성화 되어있다고 가정하면
334,000 * 400 * 0.1 = 13,360,000번의 API 호출이 발생함.
단점: 서버의 부하.

결론: 백엔드 우선 소규모로 시작해보자.

- 로드밸런서
- API 서버
- 위치 정보 캐시(레디스)

레디스 항목중에 TTL 설정을 통해 10분이상 비활성화된 사용자는 삭제하도록 설정.

- 사용자 데이터베이스
- 위치 이동 이력 데이터베이스
- 웹 소켓 서버

실시간 통신을 위해서 사용, 클라이언트의 초기화 담당.

- 레디스 펍/섭

메세지 브로커 구현체중 하나이다.

1. 모바일 클라이언트가 위치가 변경된 사실을 로드밸런서에 전송
2. 웹소켓 서버를 통해 수신한 특정 사용자의 위치 정보 변경 이벤트를 위치 이동 이력 데이터베이스에 저장.
3. 위치 정보 변경 이벤트를 레디스에 저장. -> TTL 업데이트
4. 위치 정보 변경 이벤트를 해당 사용자에게 배정된 펍/섭 채널에 발행.
5. 해당 사용자의 친구들은 해당 채널의 구독자로 설정되어있음.
6. 웹소켓 연결 핸들러가 호출됨
7. 이벤트를 수신할 친구가 활성상태면 거리를 계산
8. 계산 거리가 검색 반경 이내면 갱신 위치와 갱신 시각을 클라이언트로 전송

> 사용해본적 있는 RabbitMQ와 비교
>
> RabbitMQ
> - 메시지 전달 보장 (Guaranteed Delivery)
> - 메시지 지속성 (Persistence) 지원
> - 메시지 확인 (Acknowledgment) 메커니즘 제공
> - 실패 시 재전송 기능 제공
> - 상대적으로 더 많은 리소스 사용
>
> Redis Pub/Sub
> - 메시지 전달 보장 없음
> - 메시지 지속성 없음 (휘발성)
> - 메시지 확인 메커니즘 없음
> - 재전송 기능 없음
> - 매우 높은 처리량
> - 단순한 구조로 인한 낮은 지연시간
> - 가벼운 리소스 사용

### API 설계

일반적인 친구 추가, 삭제 사용자 정보 갱신 API 는 생략

웹 소켓 서버의 API

[ServerApi]:

- 웹소켓 초기화 API
- 본인 위치 정보 갱신 API

[ClientApi]:

- 친구 위치 정보 갱신 API
- 새 친구 구독 API
- 친구 구독 해제 API

### 데이터 모델

[위치 정보 캐시]

활성 상태 친구의 가장 최근 위치를 보관.
Redis Key Value 를 통해서 구현

위치 정보에 데이터베이스를 사용하지 않는 이유?

- "현재 위치" 만을 이용
- TTL 을 통해서 자동제거 가능.

[위치 이동 이력 데이터베이스]

user_id, latitude, longitude, timestamp 로 구성
샤딩이 쉬운 구조로 이루어져있음.
카산드라 DB 를 활용하도록







