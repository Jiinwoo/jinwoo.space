---
date: '2024-11-26'
title: "대규모 시스템 설계 기초 2 TIL - 2"
tags: [ 'study', "TIL" ]
summary: "4장 분산 메시지 큐"
thumbnail: '../../common.png'
---

풀 모델을 지원하는 메시지 큐의 동작 흐름도.

1. 소비자 그룹에 합류하고 토픽을 구독하길 원하는 새로운 소비자가 등장.
2. 소비자는 그룹 이름을 해싱하여 브로커 노드를 찾는다. -> 같은 소비자 그룹의 모든 소비자들은 같은 브로커에 연결됨
3. 해당 브로커 노드는 소비자 그룹의 코디네이터라고 부름. 브로커 클러스터 조정 작업과 다름. 
4. 코디네이터는 소비자를 그룹에 참여하고 파티션을 할당. 파티션 할당 정책에는 라운드 로빈, 범위 기반 정책 등 여러가지가 존재.
5. 소비자는 상태저장소(state storage) 로부터 오프셋 정보를 가져옴.
6. 소비자는 메시지를 처리하고 새로운 오프셋을 브로커에 보냄. 


### 소비자 재조정.

- 소비자와 코디네이터 간에 Heartbeat 교환을 통해서 조정.
- 코디네이터는 소비자 그룹중에서 임의로 리더를 선출.
- 리더로부터 파티션 계획을 전달받아서 다른 소비자들에게 전달.
- 소비자들은 새로운 파티션 할당을 받아서 처리.


### 상태 저장소

- 소비자에 대한 파티션의 배치 관계 저장.
- 각 소비자 그룹이 각 파티션에서 처리한 마지막 오프셋 정보 저장.

데이터 특징.
1. 읽기 쓰기가 빈번하게 발생하지만 양은 많지 않음.
2. 데이터 갱신은 빈번하게 일어나지만 삭제되는 일은 거의 없다.
3. 읽기 쓰기가 무작위적 패턴.
4. 데이터 일관성이 중요. 

Apache Zookeeper, etcd 

> [동물원을-탈출한-카프카](https://psm1782.medium.com/%EB%8F%99%EB%AC%BC%EC%9B%90%EC%9D%84-%ED%83%88%EC%B6%9C%ED%95%9C-%EC%B9%B4%ED%94%84%EC%B9%B4-zookeeper-less-kafka-a71cba58d5d9)

### 메타데이터 저장소.

- 토픽 설정이나 속성 정보를 저장. (파티션 수, 메시지 보관 기간, 사본 배치 정보 등

데이터 특징.
1. 자주 변경되지 않으며 양도 적음.
2. 높은 일관성 요구



## 복제.

하드웨어 장애에 대비하여서 파티션 내의 데이터를 복제하여 안정성을 확보.

사본을 어떻게 어떻게 분산할지 기술하는 것 -> 사본 분산 계획 (replica distribution plan)

예) 토픽 A의 파티션-1: 사본 3개 리더는 브로커-1, 단순 사본은 브로커-2, 브로커-3 배치

사본 분산 계획은 조정 서비스에 의해서 브로커 노드 가운데 하나가 선정되면 해당 리더 브로커 노드가 
사본 분산 계획을 만들고 메타데이터 저장소에 보관.

### 사본 동기화

메시지 소실을 대비해서 각 파티션은 여러 사본으로 복제됨.

메시지는 리더한테만 보내고 다른 단순 사본은 리더에서 메시지를 가져와서 동기화.

동기화는 어떻게??

In-Sync Replicas (ISR) : 리더와 동기화된 사본들.

예를들어 replica.lag.max.message 의 값이 4일 경우
단순 사본에 보관된 메시지 개수와 리더 사이의 차이가 3개 이하면 ISR 상태.

- 리더 사본의 합의 오프셋(committed offset) 의미: 이 오프셋 이전에 기록된 모든 메시지는 ISR 집합 내 모든 사본에 동기화가 끝났다는 것.

> - ISR 크기가 너무 작아지면 가용성에 문제가 생길 수 있음
> - min.insync.replicas 설정값이 너무 높으면 성능이 저하될 수 있음

ISR 이 필요한 이유. 성능과 영속성 사이의 타협점. 



### ACK=all

모든 ISR 사본이 메시지를 처리하고 오프셋을 보내야지만 메시지 처리가 완료됨.

### ACK=1

리더 사본만 메시지를 처리하고 오프셋을 보내면 메시지 처리가 완료됨.

데이터가 사라져도 괜찮은 경우에 사용.

### ACK=0 

수신 확인 메시지를 기다리지 않음.

Metric, Log, Event 등의 데이터에 사용.


> 리더 사본에 요청이 너무 몰리면 어떻게 될까? ISR 요건을 만족하는 사본에서 메시지를 가져가지 않는 이유?
> - 설계 및 운영이 단순.
> - 특정 파티션의 메시지는 같은 소비자 그룹 안에서 오직 한 소비자만 읽어갈 수 있으므로 리더 사본에 대한 연결이 많지 않음.
> - 인기있는 토픽의 경우 파티션 및 소비자 수를 늘려 규모를 확장.


## 규모 확장성

### 생산자, 소비자

생산자 - 간단
소비자 - 소비자 그룹은 서로 독립적으로 쉽게 추가 및 삭제 가능. 재조정 코디네이터에 의해서 진행.


### 브로커

> 146p 그림 4.28 브로커 노드의 장애 참고

1. 메시지가 성공적으로 합의(committed) 되었다고 판단하려면 얼마나 많은 사본에 메시지가 반영되어야하는가? 응답 지연과 안정성 사이의 트레이드 오프 고려
2. 파티션의 모든 사본이 같은 브로커에 배치되지 않도록 주의. 브로커 장애시 모든 사본이 손실될 수 있음.

> 148p 그림 4.29 새 브로커 노드의 추가 참고

한시적으로 시스템에 설정된 사본 수 보다 많은 사본을 허용. -> 브로커 추가
한시적으로 시스템에 설정된 사본 수 보다 적은 사본을 유지. -> 브로커 삭제

### 파티션

파티션 수를 조정해야할 때 생산자는 브로커와 통신할 때 통지 받으며 소비자는 재조정을 시행함. -> 생산자와 소비자의 안정성에는 영향을 끼치지 않음.



## 메시지 전달 방식

### 최대 한번
ACK=0

### 최소 한번
ACK=1, ACK=all

### 정확히 한번
[Exactly Once Semantics](https://huisam.tistory.com/entry/kafka-message-semantics)


## 고급 기능

### 메시지 필터링

생산자는 토픽에 모든 메시지를 발행하지만 소비자가 해당 토픽의 특정한 이벤트만 가져오고 싶은 경우가 있음.

간단한 방법 -> 토픽을 분리하는 것
다음의 단점이 존재.
1. 요구사항 마다 토픽을 분리하는 것은 관리상 어려움.
2. 토픽을 분리하면서 생기는 데이터 중복 문제.
3. 생산자와 소비자 결합도 증가.

모든 메시지를 소비자에서 필요없는 메시지는 버리는 방법이 있음.

다음의 단점이 존재.
1. 불필요한 트래픽 발생 -> 네트워크 부하
2. 성능 저하

브로커 레벨에서 메시지 필터링을 지원하는 방법이 있음.

다음의 사항들을 고려해야함.

1. 필터를 위해 복호화나 역직렬화가 필요하다면 성능이 저하됨.
2. payload가 아닌 metadata 영역을 효율적으로 활용 -> tag, header 등

### 메시지 지연 전송

# 추가적으로 알아보기

- AMQP 프로토콜
- Kafka Protocol
- Retry Consumer (메시지 소비 재시도)



